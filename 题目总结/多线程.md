## 多线程

#### 1.创建线程有哪几种方式？

1.继承Thread 实现run()方法, 调用start()方法

2.实现Rrunnable 实现 run()方法, 调用start()方法

3,实现Callable 实现call()方法,使用FutureTask.get()获取返回值

#### 2.说一下 runnable 和 callable 有什么区别？

Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；

Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。

#### 3.sleep() 和 wait() 有什么区别？

1.所属类: 首先，这两个方法来自不同的类分别是Thread和Object ，wait是Object的方法，sleep是Thread的方法

2.作用范围: sleep方法没有释放锁，只是休眠，而wait释放了锁，使得其他线程可以使用同步控制块或方法

3.使用范围: wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用

4.异常范围： sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

#### 4.notify()和 notifyAll()有什么区别？

1.如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。

2.当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。

3.优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。

#### 5.创建线程池有哪几种方式？

Java通过Executors提供四种线程池，分别为：

newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。

newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

一般使用ThreadPoolExecutor

#### 6.ThreadLocal 是什么？有哪些使用场景？

线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

#### 7.Java线程池核心线程数与最大线程数的区别

- **corePoolSize :**核心线程数

  线程池维护的最小线程数量，核心线程创建后不会被回收（注意：设置allowCoreThreadTimeout=true后，空闲的核心线程超过存活时间也会被回收）。
  大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。
  线程池刚创建时，里面没有一个线程，当调用 execute() 方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新线程并运行这个任务。

- **maximunPoolSize:**最大线程数、

  线程池允许创建的最大线程数量。
  当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。

- **keepAliveTime：**空闲线程存活时间

  当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。
  可被回收的线程：
  设置allowCoreThreadTimeout=true的核心线程。
  大于核心线程数的线程（非核心线程）。

- **workQueue：**工作队列

  存放待执行任务的队列：当提交的任务数超过核心线程数大小后，再提交的任务就存放在工作队列，任务调度时再从队列中取出任务。它仅仅用来存放被execute()方法提交的Runnable任务。工作队列实现了BlockingQueue接口。

- **handler：**拒绝策略
  AbortPolicy：默认策略；新任务提交时直接抛出未检查的异常RejectedExecutionException，该异常可由调用者捕获。
  CallerRunsPolicy：既不抛弃任务也不抛出异常，使用调用者所在线程运行新的任务。
  DiscardPolicy：丢弃新的任务，且不抛出异常。
  DiscardOldestPolicy：调用poll方法丢弃工作队列队头的任务，然后尝试提交新任务

#### 8. 怎么设置线程池核心线程数与最大线程数

CPU密集型：核心线程数 = CPU核数 + 1【机器学习、视频转码】
IO密集型：核心线程数 = CPU核数 * 2 【Web应用】
